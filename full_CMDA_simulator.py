#!/usr/bin/env python3
"""
helixdag_realtime_simulator.py

Real-time multi-node HelixDAG-like simulator using real hashing (BLAKE2b),
per-miner Continuous Micro-Difficulty Adjustment (CMDA), transactions,
energy accounting, and comparative energy-usage plotting.

Features:
- Creates N miner nodes (default 5) running concurrently (threads).
- Each node generates transactions and attempts to mine blocks by hashing
  block header + nonce using BLAKE2b.
- Per-miner CMDA using EWMA on observed inter-block intervals.
- Tracks hashes performed and estimates energy consumed (Joules) per miner.
- Runs two experiment modes in one run: (A) CMDA enabled, (B) fixed difficulty.
- Produces plots comparing orphan rate, throughput and energy consumption.

Usage:
    python helixdag_realtime_simulator.py

Requirements:
    Python 3.8+, numpy, matplotlib

Notes:
- This is a simulator: the hashing loop is real (BLAKE2b) and may consume CPU
  if you increase difficulty or number of miners. Default parameters keep the
  experiment light. Adjust SIM_DURATION and DIFFICULTY_SCALE if you want
  heavier experiments.

Author: Generated by ChatGPT (adapted to user's request)
"""

import threading
import time
import random
import hashlib
import struct
from dataclasses import dataclass, field
from typing import List, Dict, Optional
import numpy as np
import matplotlib.pyplot as plt

# -----------------------------
# Configurable parameters
# -----------------------------
NUM_MINERS = 5
SIM_DURATION = 30.0         # run time in seconds (wall-clock)
TARGET_INTERVAL = 3.0       # target inter-block time in seconds
ALPHA = 0.2                 # CMDA EWMA learning rate
INITIAL_DIFFICULTY = 2 ** 20  # target threshold denominator (lower -> harder)
ENERGY_PER_HASH = 5e-9      # Joules per hash (example)
BLAKE_OUT_BITS = 256

# mining mode: "cmda" (adaptive per-miner) compared to "fixed" (no adaptation)
# script will run both modes sequentially to compare energy usage.

# Transaction generation
TX_PER_SEC_PER_NODE = 2

# Thread coordination
PRINT_PROGRESS = True

# -----------------------------
# Data structures
# -----------------------------
@dataclass
class Transaction:
    txid: str
    sender: str
    receiver: str
    amount: float
    timestamp: float

@dataclass
class Block:
    height: int
    prev_hash: str
    miner_id: str
    timestamp: float
    nonce: int
    txs: List[Transaction]
    difficulty: int  # numeric difficulty (lower target means harder)
    block_hash: Optional[str] = None

@dataclass
class MinerStats:
    mined_blocks: int = 0
    hashes: int = 0
    energy_joules: float = 0.0
    last_block_time: Optional[float] = None
    ewma_interval: float = TARGET_INTERVAL
    local_difficulty: int = INITIAL_DIFFICULTY
    orphaned_blocks: int = 0

# -----------------------------
# Utilities
# -----------------------------

def blake2b_hash(header_bytes: bytes) -> bytes:
    h = hashlib.blake2b(digest_size=BLAKE_OUT_BITS // 8)
    h.update(header_bytes)
    return h.digest()


def header_to_bytes(height: int, prev_hash: str, miner_id: str, timestamp: float, nonce: int) -> bytes:
    # deterministic packing for header
    s = f"{height}:{prev_hash}:{miner_id}:{timestamp:.6f}:{nonce}"
    return s.encode('utf-8')


def hash_meets_target(digest: bytes, difficulty: int) -> bool:
    # Interpret digest as big integer. We define a target threshold: max_int // difficulty
    value = int.from_bytes(digest, byteorder='big')
    max_int = 2 ** BLAKE_OUT_BITS - 1
    target = max_int // difficulty
    return value <= target


def now():
    return time.time()

# -----------------------------
# Node / Miner implementation
# -----------------------------
class Miner(threading.Thread):
    def __init__(self, miner_id: str, global_state, mode: str = 'cmda'):
        super().__init__()
        self.miner_id = miner_id
        self.global_state = global_state
        self.mode = mode  # 'cmda' or 'fixed'
        self.stats = MinerStats()
        self.stop_event = threading.Event()
        self.tx_pool: List[Transaction] = []
        self.random = random.Random(hash(miner_id) & 0xffffffff)

    def run(self):
        # Start transaction generator in a lightweight loop.
        tx_thread = threading.Thread(target=self._generate_transactions_loop, daemon=True)
        tx_thread.start()
        while not self.stop_event.is_set() and not self.global_state['stop_all']:
            # prepare block header
            with self.global_state['lock']:
                height = self.global_state['height']
                prev_hash = self.global_state['tip_hash']
            txs = self._grab_transactions()
            difficulty = self._current_difficulty()
            # mining loop: try nonces until find a hit or stop condition
            nonce = 0
            found = False
            start_h = now()
            while not found and not self.stop_event.is_set() and not self.global_state['stop_all']:
                header = header_to_bytes(height + 1, prev_hash, self.miner_id, now(), nonce)
                digest = blake2b_hash(header)
                self.stats.hashes += 1
                if hash_meets_target(digest, difficulty):
                    found = True
                    block_hash_hex = digest.hex()
                    timestamp = now()
                    block = Block(height + 1, prev_hash, self.miner_id, timestamp, nonce, txs, difficulty, block_hash_hex)
                    self._broadcast_block(block)
                    self.stats.mined_blocks += 1

                    if self.stats.last_block_time is not None:
                        observed_interval = timestamp - self.stats.last_block_time

                        # --- Predictive EWMA Level ---
                        prev_level = self.stats.ewma_interval
                        level = (1 - ALPHA) * prev_level + ALPHA * observed_interval
                        self.stats.ewma_interval = level

                        # --- Predictive Trend ---
                        trend_prev = getattr(self.stats, 'trend', 0.0)
                        beta = 0.1
                        trend = beta * (level - prev_level) + (1 - beta) * trend_prev
                        self.stats.trend = trend

                        # --- Forecast ---
                        predicted_interval = level + trend

                        # --- Full CMDA multiplicative update ---
                        ratio = max(0.1, predicted_interval / TARGET_INTERVAL)
                        gamma = 0.5
                        new_diff = int(self.stats.local_difficulty * pow(ratio, gamma))
                        self.stats.local_difficulty = max(2, new_diff)

                    self.stats.last_block_time = timestamp
                    break
                nonce += 1 
                # To avoid busy spinning too tight on Python, yield occasionally
                if nonce % 1000 == 0:
                    time.sleep(0)
            end_h = now()
            # estimate energy: number of hashes * ENERGY_PER_HASH
            self.stats.energy_joules = self.stats.hashes * ENERGY_PER_HASH
            # small sleep to allow others to run
            time.sleep(0.01)
        if PRINT_PROGRESS:
            print(f"Miner {self.miner_id} stopping. Mined: {self.stats.mined_blocks}, Hashes: {self.stats.hashes}, Energy: {self.stats.energy_joules:.6f} J")

    def stop(self):
        self.stop_event.set()

    def _current_difficulty(self) -> int:
        if self.mode == 'cmda':
            return self.stats.local_difficulty
        else:
            return INITIAL_DIFFICULTY

    def _broadcast_block(self, block: Block):
        # naive single-leader update: if height advances, accept; else treat as orphan
        with self.global_state['lock']:
            if block.height > self.global_state['height']:
                # accept
                self.global_state['height'] = block.height
                self.global_state['tip_hash'] = block.block_hash
                self.global_state['chain'].append(block)
                self.global_state['accepted_blocks'].append(block)
                # record which miner produced it
                self.global_state['miner_map'][block.block_hash] = block.miner_id
                if PRINT_PROGRESS:
                    print(f"[ACCEPT] Miner {block.miner_id} mined block {block.height} (nonce={block.nonce}) diff={block.difficulty}")
            else:
                # orphan
                self.global_state['orphaned_blocks'].append(block)
                self.global_state['miner_map'][block.block_hash] = block.miner_id
                if PRINT_PROGRESS:
                    print(f"[ORPHAN] Miner {block.miner_id} mined orphan at height {block.height} (current height {self.global_state['height']})")

    def _generate_transactions_loop(self):
        while not self.stop_event.is_set() and not self.global_state['stop_all']:
            # generate TX_PER_SEC_PER_NODE transactions per second roughly
            count = max(1, int(TX_PER_SEC_PER_NODE))
            for _ in range(count):
                tx = Transaction(
                    txid=f"{self.miner_id}-{time.time_ns()}-{self.random.randint(0, 1<<30)}",
                    sender=self.miner_id,
                    receiver=f"N{self.random.randint(0, NUM_MINERS-1)}",
                    amount=round(self.random.random() * 10, 4),
                    timestamp=now(),
                )
                self.tx_pool.append(tx)
            time.sleep(1.0)

    def _grab_transactions(self, max_txs: int = 20) -> List[Transaction]:
        txs = []
        while self.tx_pool and len(txs) < max_txs:
            txs.append(self.tx_pool.pop(0))
        return txs

# -----------------------------
# Experiment runner
# -----------------------------

def run_experiment(mode: str) -> Dict:
    """Run a single wall-clock experiment with miners in mode: 'cmda' or 'fixed'.
    Returns collected metrics.
    """
    # global shared state
    global_state = {
        'lock': threading.Lock(),
        'height': 0,
        'tip_hash': '0' * 64,
        'chain': [],
        'accepted_blocks': [],
        'orphaned_blocks': [],
        'miner_map': {},
        'stop_all': False,
    }
    # create miners
    miners = [Miner(f"M{i}", global_state, mode=mode) for i in range(NUM_MINERS)]
    # initialize local difficulties for CMDA miners
    for m in miners:
        m.stats.local_difficulty = INITIAL_DIFFICULTY
    # start miners
    for m in miners:
        m.start()
    start_time = now()
    try:
        while now() - start_time < SIM_DURATION:
            time.sleep(1.0)
    except KeyboardInterrupt:
        print("Interrupted")
    # signal stop
    global_state['stop_all'] = True
    # wait for miners to stop
    for m in miners:
        m.stop()
    for m in miners:
        m.join()
    # collect metrics
    total_hashes = sum(m.stats.hashes for m in miners)
    total_energy = sum(m.stats.energy_joules for m in miners)
    total_blocks = sum(m.stats.mined_blocks for m in miners)
    accepted = len(global_state['accepted_blocks'])
    orphaned = len(global_state['orphaned_blocks'])
    throughput = accepted / max(1.0, SIM_DURATION)
    # per-miner stats
    per_miner = {m.miner_id: {'blocks': m.stats.mined_blocks, 'hashes': m.stats.hashes, 'energy': m.stats.energy_joules, 'final_diff': m.stats.local_difficulty} for m in miners}
    metrics = {
        'mode': mode,
        'total_hashes': total_hashes,
        'total_energy': total_energy,
        'total_blocks': total_blocks,
        'accepted_blocks': accepted,
        'orphaned_blocks': orphaned,
        'throughput_bps': throughput,
        'per_miner': per_miner,
        'chain': global_state['chain'],
    }
    return metrics

# -----------------------------
# Plotting & driver
# -----------------------------

def plot_comparison(metrics_cmda, metrics_fixed):
    labels = ['CMDA', 'Fixed']
    energies = [metrics_cmda['total_energy'], metrics_fixed['total_energy']]
    blocks = [metrics_cmda['accepted_blocks'], metrics_fixed['accepted_blocks']]
    throughputs = [metrics_cmda['throughput_bps'], metrics_fixed['throughput_bps']]
    orphan_rates = [metrics_cmda['orphaned_blocks'] / max(1, metrics_cmda['total_blocks']), metrics_fixed['orphaned_blocks'] / max(1, metrics_fixed['total_blocks'])]

    x = np.arange(len(labels))
    fig, axs = plt.subplots(2, 2, figsize=(10, 8))
    axs[0, 0].bar(x, energies)
    axs[0, 0].set_title('Total Energy (J)')
    axs[0, 0].set_xticks(x)
    axs[0, 0].set_xticklabels(labels)

    axs[0, 1].bar(x, blocks)
    axs[0, 1].set_title('Accepted Blocks')
    axs[0, 1].set_xticks(x)
    axs[0, 1].set_xticklabels(labels)

    axs[1, 0].bar(x, throughputs)
    axs[1, 0].set_title('Throughput (blocks/sec)')
    axs[1, 0].set_xticks(x)
    axs[1, 0].set_xticklabels(labels)

    axs[1, 1].bar(x, orphan_rates)
    axs[1, 1].set_title('Orphan Rate')
    axs[1, 1].set_xticks(x)
    axs[1, 1].set_xticklabels(labels)

    plt.tight_layout()
    plt.savefig('helixdag_energy_comparison.png')
    print('Saved plot to helixdag_energy_comparison.png')
    plt.show()


def main():
    print('=== HelixDAG Real-time Simulator (BLAKE2b) ===')
    print(f'NUM_MINERS={NUM_MINERS}, SIM_DURATION={SIM_DURATION}s, TARGET_INTERVAL={TARGET_INTERVAL}s')
    print('Running CMDA experiment...')
    metrics_cmda = run_experiment(mode='cmda')
    print('\nCMDA metrics:')
    print(f"Total energy: {metrics_cmda['total_energy']:.6f} J, Accepted blocks: {metrics_cmda['accepted_blocks']}, Orphans: {metrics_cmda['orphaned_blocks']}")

    print('\nRunning Fixed-difficulty experiment...')
    metrics_fixed = run_experiment(mode='fixed')
    print('\nFixed metrics:')
    print(f"Total energy: {metrics_fixed['total_energy']:.6f} J, Accepted blocks: {metrics_fixed['accepted_blocks']}, Orphans: {metrics_fixed['orphaned_blocks']}")

    # plot comparison
    plot_comparison(metrics_cmda, metrics_fixed)

    # print per-miner table for CMDA
    print('\nPer-miner stats (CMDA):')
    for mid, s in metrics_cmda['per_miner'].items():
        print(f"{mid}: blocks={s['blocks']}, hashes={s['hashes']}, energy={s['energy']:.6f} J, final_diff={s['final_diff']}")

    print('\nDone.')

if __name__ == '__main__':
    main()

